import os
import sys
import subprocess

def clean_up_output(text):
    txt=text.split('\n')
    text_new=''
    for line in txt: 
        if "mkdir: cannot create directory '/.local': Permission denied" in line: continue
        text_new += line+'\n'
    return text_new

def get_status_output(*args, **kwargs):
    #from subprocess import Popen
    p = subprocess.Popen(*args, **kwargs)
    stdout, stderr = p.communicate()
    return p.returncode, stdout, stderr


def run_exe(exe):
    #if sys.version_info[0] < 3:
    #    from commands import getstatusoutput
    #    status, output = getstatusoutput(exe)
    #else:
    status, stdout, stderr = get_status_output(exe.split(), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output =  stdout.decode("utf-8")
    if status != 0: raise Exception("ERROR: happend while executing "+exe+" : " + output)
    output = clean_up_output(output)
    return output


def calc_pkas_acdlabs(smi_list):
    # use ACDlabs.
    # perceptabat executable should be in the path.

    pka_lim_base_1=2
    pka_lim_base_2=15
    pka_lim_acid_1=-5
    pka_lim_acid_2=12

    tmpfile='TMP_SMI_FOR_PKA.smi'
    #tmpfile4='TMP_SMI_FOR_PKA.json'
    if os.path.isfile(tmpfile): os.remove(tmpfile)
    with open(tmpfile,'w') as smifile:
        i=0
        for smi in smi_list:
            i+=1
            smifile.write(smi+" tmpname"+str(i)+'\n')

    tmpfile2='TMP_CLAB_OUTPUT.txt'
    if os.path.isfile(tmpfile2): os.remove(tmpfile2)
    #exe = 'perceptabat -TFNAME'+tmpfile2+' -MPKAAPP -TPKA ' + tmpfile
    exe = 'perceptabat -TFNAME'+tmpfile2+' -MPKAAPPGALAS -TPKA ' + tmpfile
    tmpoutput = run_exe(exe)
    if not os.path.isfile(tmpfile2): 
        print("ERROR: no tmpfile generated by acdlabs "+tmpfile2)
        sys.exit(1)


    with open(tmpfile2,'r') as f:
        base_pkas=[]
        acid_pkas=[]
        diacid_pkas=[]
        D={}
        f.readline() # skip first line
        for line in f.readlines():
            ln=line.split()
            mol_idx = int(ln[0])
            if mol_idx not in D.keys(): D[mol_idx]={}
            #if 'ACD_pKa_Apparent' in ln[1]: D[mol_idx]['pka']=float(ln[2])
            if 'ACD_pKa_Apparent' in ln[1]: pka = float(ln[2])
            if 'ACD_pKa_DissType_Apparent' in ln[1]: 
                if ln[2] in ['MB','B']:
                    if pka > pka_lim_base_1 and pka < pka_lim_base_2: 
                        base_pkas.append((pka,smi_list[mol_idx-1]))
                if ln[2] in ['MA','A']:
                    if pka > pka_lim_acid_1 and pka < pka_lim_acid_2: 
                        acid_pkas.append((pka,smi_list[mol_idx-1]))

### Examle of perceptabatch output 
#PKA: Calculate apparent values using classic algorithm
#1	 ID: 1
#1	 ACD_pKa_IonicForm_Apparent: L
#1	 ACD_pKa_Apparent_1: 10.689
#1	 ACD_pKa_Error_Apparent_1: 0.10
#1	 ACD_pKa_DissAtom_Apparent_1: 5
#1	 ACD_pKa_DissType_Apparent_1: MB
#1	 ACD_pKa_Equation_Apparent_1: HL/H+L
#1	 ACD_pKa_All_Apparent_1: pKa(HL/H+L; 5) = 10.69+/-0.10
#2	 ID: 2
#2	 ACD_pKa_IonicForm_Apparent: L
#...
#4	 ID: 4
#4	 ACD_pKa_Caution_Apparent: The structure does not contain ionization centers calculated by current version of ACD/pKa
#5	 ID: 5
#5	 ACD_pKa_IonicForm_Apparent: L
#5	 ACD_pKa_Apparent_1: 10.679
#5	 ACD_pKa_Error_Apparent_1: 0.10
#5	 ACD_pKa_DissAtom_Apparent_1: 1
#5	 ACD_pKa_DissType_Apparent_1: MB
#5	 ACD_pKa_Equation_Apparent_1: HL/H+L
#5	 ACD_pKa_All_Apparent_1: pKa(HL/H+L; 1) = 10.68+/-0.10
#5	 ACD_pKa_Apparent_2: 9.334
#5	 ACD_pKa_Error_Apparent_2: 0.10
#5	 ACD_pKa_DissAtom_Apparent_2: 6
#5	 ACD_pKa_DissType_Apparent_2: B 
#5	 ACD_pKa_Equation_Apparent_2: H2L/H+HL
#5	 ACD_pKa_All_Apparent_2: pKa(H2L/H+HL; 6) = 9.33+/-0.10

    lClean=False
    if lClean:     
            if os.path.isfile(tmpfile): os.remove(tmpfile)
            if os.path.isfile(tmpfile2): os.remove(tmpfile2)

    return (base_pkas,acid_pkas,diacid_pkas)