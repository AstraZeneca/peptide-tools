#!/usr/bin/python
import argparse
import csv
import json
import os
import random
import re
import string
import sys
import time
import urllib
from operator import itemgetter
from time import gmtime
from time import strftime

from peptools.io import generate_input
from pichemist.api import pichemist_from_dict
from rdkit import Chem

from molecular_descriptors import calc_molecular_descriptors_from_dict
from extn_coeff_fasta import calc_extn_coeff
#from pI_fasta import calc_pI_fasta

from liabilities import calc_liabilities_from_dict

currentdir = os.getcwd()

__prog__ = "Peptide Tools Master"
__doc__ = """TODO"""


def arg_parser():
    parser = argparse.ArgumentParser(description="")
    parser.add_argument(
        "-i",
        "--input",
        dest="input",
        help="Input filepath (or SMILES string or FASTA)",
        required=True,
    )

    parser.add_argument(
        "--print_fragment_pkas",
        action="store_true",
        dest="print_fragment_pkas",
        help="Print the fragments with corresponding pKas used in pI calcution.",
        default=False,
    )

    parser.add_argument(
        "--generate_fragment_images",
        default=False,
        action="store_true",
        dest="generate_fragment_images",
        help="Generate 2D depiction of the frgament smiles in base64 format.",
    )

    parser.add_argument(
        "--print_pka_set",
        action="store_true",
        dest="print_pka_set",
        help="Print out stored pka sets.",
        default=False,
    )

    ### keys for fasta input
    parser.add_argument(
        "--ionizable_cterm",
        dest="ionizable_cterm",
        action="store_true",
        help="is C-terminus ionizable [COO-]?",
        default=False,
    )
    parser.add_argument(
        "--ionizable_nterm",
        dest="ionizable_nterm",
        action="store_true",
        help="is N-terminus ionizable [N+]?",
        default=False,
    )
    args = parser.parse_args()
    return args


if __name__ == "__main__":
    args = arg_parser()
    # Generate input and parameters
    input_data = args.input
    mol_supply_json, params = generate_input(input_data)

    # TODO: need to introduce logic. if the output is a file then 
    # disable --print_fragment_pkas, --generate_fragment_base64_images

    # Run calcs

    dict_out_molecular_descriptors = calc_molecular_descriptors_from_dict(
        mol_supply_json,
        input_type=params.input_type,        
    )

    dict_out_liabilities = calc_liabilities_from_dict(
        mol_supply_json,
        input_type=params.input_type,        
    )

    dict_out_extn_coeff_fasta = {}
    if params.calc_extn_coeff:
        extn_coeff_options = {
            "seq": "",
            "inputDict": mol_supply_json,
            "inputJSON": "",
            "inputFile": "",
            "outputFile": "",
            "l_json": True,
        }
        dict_out_extn_coeff = calc_extn_coeff(extn_coeff_options)

    dict_out_pIChemiSt = {}
    if params.calc_pIChemiSt:
        plot_filename_prefix = "temp"
        if params.filepath_prefix:
            plot_filename_prefix = params.filepath_prefix

        # Since pichamist cant' treat input_type we need to erase part of the information in mol_supply_json generated by generate_input function depending on teh input_type
        mol_supply_json_temp = mol_supply_json
        mol_supply_json = dict()
        if params.input_type == "structure":
            for mol_idx,mol_dict in mol_supply_json_temp.items():
                mol_dict["fasta"] = None
                mol_supply_json[mol_idx] = mol_dict
        else:
            for mol_idx,mol_dict in mol_supply_json_temp.items():
                mol_dict["mol_obj"] = None
                mol_supply_json[mol_idx] = mol_dict
            
        dict_out_pIChemiSt = pichemist_from_dict(
            mol_supply_json,
            method="pkamatcher",
            ph_q_curve_file_prefix=plot_filename_prefix,
            plot_ph_q_curve=params.generate_plots,
            print_fragments=args.print_fragment_pkas,
            #input_type=params.input_type,
            ionizable_nterm=args.ionizable_nterm,
            ionizable_cterm=args.ionizable_cterm,
            generate_fragment_images=args.generate_fragment_images,
        )

    dict_out_peptide_tools_master = {
        "output_molecular_descriptors":dict_out_molecular_descriptors,
        "output_extn_coeff": dict_out_extn_coeff,
        "output_pIChemiSt": dict_out_pIChemiSt,
        "output_liabilities":dict_out_liabilities,
    }

    ### ----------------------------------------------------------------------
    # Output
    if params.output_filename == "":  # output JSON
        print(json.dumps(dict_out_peptide_tools_master, indent=2))

    else:  # output file
        if params.input_file_extension != ".fasta":

            # for mi in mol_supply_json.keys():
            mol_list = []
            for mi in mol_supply_json.keys():
                mol = mol_supply_json[mi]["mol_obj"]

                if params.calc_pIChemiSt:
                    mol.SetProp(
                        "pI mean", "%.2f" % dict_out_pIChemiSt[mi]["pI"]["pI mean"]
                    )
                    mol.SetProp("pI std", "%.2f" % dict_out_pIChemiSt[mi]["pI"]["std"])
                    mol.SetProp(
                        "pI interval",
                        " - ".join(
                            ["%.2f" % x for x in dict_out_pIChemiSt[mi]["pI_interval"]]
                        ),
                    )
                    mol.SetProp(
                        "pI interval threshold",
                        "%.2f" % dict_out_pIChemiSt[mi]["pI_interval_threshold"],
                    )

                if params.calc_extn_coeff:
                    mol.SetProp("mol_name", dict_out_extn_coeff[mi]["mol_name"])
                    mol.SetProp("Sequence(FASTA)", dict_out_extn_coeff[mi]["fasta"])
                    mol.SetProp("e205(nm)", "%i" % dict_out_extn_coeff[mi]["e205"])
                    mol.SetProp("e214(nm)", "%i" % dict_out_extn_coeff[mi]["e214"])
                    mol.SetProp("e280(nm)", "%i" % dict_out_extn_coeff[mi]["e280"])

                mol_list.append(mol)

            if params.output_file_extension == ".sdf":
                with Chem.SDWriter(params.output_filename) as sdf_w:
                    for mol in mol_list:
                        sdf_w.write(mol)

            elif params.output_file_extension == ".csv":
                with open(params.output_filename, "w") as csv_f:
                    csv_w = csv.writer(csv_f)
                    count = 0
                    for mol in mol_list:
                        props = mol.GetPropsAsDict()

                        count += 1
                        if count == 1:
                            header = ["SMILES"] + list(props.keys())
                            csv_w.writerow(header)

                        row = [Chem.MolToSmiles(mol)]
                        for p in header[1:]:
                            row += [props[p]]
                        csv_w.writerow(row)
        else:
            dict_list = []
            for mi in mol_supply_json.keys():
                fasta = mol_supply_json[mi]["fasta"]

                D = {}

                # if params.calc_pI_fasta:
                #     D["pI mean"] = "%.2f" % dict_out_pI_fasta[mi]["pI"]["pI mean"]
                #     D["pI std"] = "%.2f" % dict_out_pI_fasta[mi]["pI"]["std"]

                if params.calc_pIChemiSt:
                    D["pI mean"] = "%.2f" % dict_out_pIChemiSt[mi]["pI"]["pI mean"]
                    D["pI std"] = "%.2f" % dict_out_pIChemiSt[mi]["pI"]["std"]

                if params.calc_extn_coeff:
                    D["mol_name"] = dict_out_extn_coeff[mi]["mol_name"]
                    D["Sequence(FASTA)"] = dict_out_extn_coeff[mi]["fasta"]
                    D["e205(nm)"] = "%i" % dict_out_extn_coeff[mi]["e205"]
                    D["e214(nm)"] = "%i" % dict_out_extn_coeff[mi]["e214"]
                    D["e280(nm)"] = "%i" % dict_out_extn_coeff[mi]["e280"]

                dict_list.append(D)

            if params.output_file_extension == ".csv":
                with open(params.output_filename, "w") as csv_f:
                    csv_w = csv.writer(csv_f)
                    count = 0
                    for props in dict_list:

                        count += 1
                        if count == 1:
                            header = list(props.keys())
                            csv_w.writerow(header)

                        row = []
                        for p in header:
                            row += [props[p]]
                        csv_w.writerow(row)

        dict_file = {
            "outputFile": params.output_filename,
            "outputInfo": "Number of molecules processed:"
            + str(len(mol_supply_json.keys())),
        }
        print(json.dumps(dict_file))
